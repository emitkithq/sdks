/**
 * EmitKit SDK Client
 *
 * Provides a type-safe, intuitive wrapper around the auto-generated API client.
 */

import type {
  EmitKitConfig,
  RequestOptions,
  EmitKitResponse,
  RateLimitInfo
} from './types';
import {
  EmitKitError,
  RateLimitError,
  ValidationError
} from './types';

// These will be generated by @hey-api/openapi-ts
// import { client, EventsService } from './generated';
// import type { CreateEventRequest, CreateEventResponse } from './generated';

export class EmitKit {
  private readonly config: Required<EmitKitConfig>;
  private lastRateLimit?: RateLimitInfo;

  constructor(apiKey: string, config?: Partial<Omit<EmitKitConfig, 'apiKey'>>) {
    this.config = {
      apiKey,
      baseUrl: config?.baseUrl || 'https://api.emitkit.com',
      timeout: config?.timeout || 30000,
      fetch: config?.fetch || globalThis.fetch
    };

    // Configure the generated client
    // Note: This will work once openapi-ts generates the client
    // client.setConfig({
    //   baseURL: this.config.baseUrl,
    //   headers: {
    //     Authorization: `Bearer ${this.config.apiKey}`
    //   }
    // });
  }

  /**
   * Get the last known rate limit information
   */
  get rateLimit(): RateLimitInfo | undefined {
    return this.lastRateLimit;
  }

  /**
   * Events API
   */
  get events() {
    return {
      /**
       * Create a new event
       *
       * @example
       * ```ts
       * const result = await client.events.create({
       *   channelName: 'payments',
       *   title: 'Payment Received',
       *   metadata: { amount: 99.99 }
       * });
       * ```
       */
      create: async (
        data: any, // CreateEventRequest - will be typed after generation
        options?: RequestOptions
      ): Promise<EmitKitResponse<any>> => { // CreateEventResponse
        return this.request('/v1/events', {
          method: 'POST',
          body: JSON.stringify(data),
          headers: {
            'Content-Type': 'application/json',
            ...(options?.idempotencyKey && {
              'Idempotency-Key': options.idempotencyKey
            }),
            ...options?.headers
          }
        });
      }
    };
  }

  /**
   * Make a raw API request
   */
  private async request<T>(
    path: string,
    options: RequestInit
  ): Promise<EmitKitResponse<T>> {
    const url = `${this.config.baseUrl}${path}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

    try {
      const response = await this.config.fetch(url, {
        ...options,
        headers: {
          Authorization: `Bearer ${this.config.apiKey}`,
          ...options.headers
        },
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      // Extract rate limit info
      const rateLimit = this.extractRateLimit(response);
      if (rateLimit) {
        this.lastRateLimit = rateLimit;
      }

      // Check for idempotent replay
      const wasReplayed = response.headers.get('X-Idempotent-Replay') === 'true';

      // Handle errors
      if (!response.ok) {
        await this.handleErrorResponse(response, rateLimit);
      }

      // Parse success response
      const body = (await response.json()) as Record<string, unknown>;
      const requestId = (body.requestId as string | undefined) || response.headers.get('X-Request-ID');

      return {
        data: body.success ? (body.data as T) : (body as T),
        rateLimit: rateLimit!,
        requestId: requestId || 'unknown',
        wasReplayed
      };
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof EmitKitError) {
        throw error;
      }

      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          throw new EmitKitError('Request timeout', 408);
        }
        throw new EmitKitError(
          `Network error: ${error.message}`,
          0
        );
      }

      throw new EmitKitError('Unknown error occurred', 500);
    }
  }

  private extractRateLimit(response: Response): RateLimitInfo | null {
    const limit = response.headers.get('X-RateLimit-Limit');
    const remaining = response.headers.get('X-RateLimit-Remaining');
    const reset = response.headers.get('X-RateLimit-Reset');

    if (!limit || !remaining || !reset) {
      return null;
    }

    const resetTimestamp = parseInt(reset, 10) * 1000;
    const resetIn = Math.max(0, resetTimestamp - Date.now());

    return {
      limit: parseInt(limit, 10),
      remaining: parseInt(remaining, 10),
      reset: parseInt(reset, 10),
      resetIn
    };
  }

  private async handleErrorResponse(
    response: Response,
    rateLimit: RateLimitInfo | null
  ): Promise<never> {
    const body = (await response.json().catch(() => ({}))) as Record<string, unknown>;
    const requestId = (body.requestId as string | undefined) || response.headers.get('X-Request-ID') || undefined;

    // Rate limit error
    if (response.status === 429 && rateLimit) {
      throw new RateLimitError(rateLimit, requestId);
    }

    // Validation error
    if (response.status === 400 && body.details) {
      throw new ValidationError(
        (body.error as string) || 'Validation error',
        body.details as Array<{ path: string[]; message: string }>,
        requestId
      );
    }

    // Generic error
    throw new EmitKitError(
      (body.error as string) || (body.message as string) || `HTTP ${response.status}`,
      response.status,
      requestId || undefined,
      body
    );
  }
}
